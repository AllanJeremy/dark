#!/usr/bin/env python3.6

import sys
import subprocess
import threading
import fcntl
import os
import time
import tty
import termios

# http://ballingt.com/nonblocking-stdin-in-python-3/
class nonblocking(object):
    def __init__(self, stream):
        self.stream = stream
        self.fd = self.stream.fileno()
    def __enter__(self):
        self.orig_fl = fcntl.fcntl(self.fd, fcntl.F_GETFL)
        fcntl.fcntl(self.fd, fcntl.F_SETFL, self.orig_fl | os.O_NONBLOCK)
    def __exit__(self, *args):
        fcntl.fcntl(self.fd, fcntl.F_SETFL, self.orig_fl)


# Make io unbuffered
def flush(fn):
  def newfn(x):
    fn(x)
    sys.stdout.flush()
  return newfn
sys.stdout.write = flush(sys.stdout.write)
sys.stdout.writelines = flush(sys.stdout.writelines)

def run(bash):
  proc = subprocess.run(bash, shell=True)
  return proc.returncode == 0

def compile(files):
  run("scripts/support/compile " + " ".join(files))

def initial_compile():
  compile(["client/Main.elm", "server/main/dark.ml"])

def process_watchers():
  with nonblocking(sys.stdin):
    while True:
      files = set()
      c = sys.stdin.read(100000)
      if c == "":
        time.sleep(1)
      else:
        for f in c.split("\n"):
          if f != "***BATCHEND***" and f != "":
            f, _ = f.strip().split(" ")
            files.add(f)
        compile(files)

def background_task(fn):
  threading.Thread(target=fn).start()


def main():
  watch = False
  compile = False
  for f in sys.argv[1:]:
    if f == "--compile":
      compile = True
    elif f == "--watch":
      watch = True

  if compile and watch:
    background_task(initial_compile)
    process_watchers()
  else:
    if compile:
      background_task(initial_compile)

    if watch:
      process_watchers()


main()

