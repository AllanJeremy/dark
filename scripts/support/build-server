#!/usr/bin/env python3.6

import os
import fcntl
import sys
import datetime
import subprocess
import threading

def run_in_background(fn):
  thread = threading.Thread(target=fn)
  thread.start()
  return thread

def run(bash, color):
  class ThreadWorker(threading.Thread):
    def __init__(self, pipe):
      super(ThreadWorker, self).__init__()
      self.pipe = pipe
      self.setDaemon(True)

    def run(self):
      for line in iter(self.pipe.readline, ''):
        p(">>> " + line, color=color, end='')


  proc = subprocess.Popen(bash, stdin=None, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=0, shell=True, encoding='utf-8')
  stdout_worker = ThreadWorker(proc.stdout)
  stderr_worker = ThreadWorker(proc.stderr)
  stdout_worker.start()
  stderr_worker.start()

  proc.wait()
  stdout_worker.join()
  stderr_worker.join()

  return proc.returncode == 0



def consolecode(color):
  return "\u001B[" + str(color) + "m"

FIRST, LAST, WHITE, RED = 31, 37, 0, 32
color = FIRST
def nextcolor():
  global color
  color = color + 1
  if color == LAST:
    color = FIRST
  return color

def p(s, end=None, color=WHITE):
  date = datetime.datetime.now().strftime("%H:%M:%S:%f")
  date = ""
  newline = ""
  if s[0] == "\n":
    s = s[1:]
    newline = "\n"
  print(newline + consolecode(color) + date + ": " + s, end=end)
  sys.stdout.flush()

def call(bash):
  color = nextcolor()
  p("$ " + bash, color=color)
  result = run(bash, color=color)
  p("X " + bash, color=color)
  return result

def ignore(filename, reason):
  # if reason != "Updated" and reason != "AttributeModified":
    # return True

  # substring
  ignores = [ ".git"
            , "scripts/"
            , "logs/"
            , ".merlin"
            , "client/elm-stuff"
            , "client/tests/elm-stuff"
            , "server/static/elm.js"
            , "server/cache/"
            , "server/_build/"
            , "server/appdata/"
            , "server/dark.byte"
            , "server/test.byte"
  ]
  for i in ignores:
    if i in filename:
      return True
  # ocaml build temporary
  if filename[-10:-8] == "/C":
    return True
  # emacs thing
  if "/.#" in filename:
    return True
  return False

def elm_package():
  return call("cd client && elm-package install --yes")

def elm_make():
  return call("cd client && elm-make Main.elm --warn --debug --yes --output ../server/static/elm.js")

def elm_test():
  return call("cd client && elm-test")

def ocaml_build():
  return call("cd server && ocamlbuild dark.byte")

def ocaml_test():
  return call("cd server && ocamlbuild test.byte && _build/test/test.byte")

def reload_server():
  return call("cd server && ../scripts/support/runserver")

def reload_browser():
  # Sends a signal to another fswatch on your mac
  return call("touch .browser-trigger")

class Should:
  def __init__(self):
    self.ocaml_build = False
    self.ocaml_test = False
    self.elm_package = False
    self.elm_make = False
    self.elm_test = False
    self.reload_browser = False
    self.reload_server = False

def execute(should):
  ob = should.ocaml_build and ocaml_build()

  ep = should.elm_package and elm_package()
  should.elm_make |= ep
  em = should.elm_make and elm_make()

  should.reload_server |= ob
  rs = should.reload_server and reload_server()
  should.reload_browser |= rs or em
  rb = should.reload_browser and reload_browser()

  should.ocaml_test |= ob
  ot = should.ocaml_test and ocaml_test()
  should.elm_test |= em
  et = should.elm_test and elm_test()

def mark(should, f):
  # Frontend
  if "elm-package.json" in f:
    should.elm_package = True
  elif "Tests.elm" in f:
    should.elm_test = True
  elif ".elm" in f:
    should.elm_make = True

  # Ocaml
  elif (".ml" in f) or ("jbuild" in f) or ("_tags" in f):
    should.ocaml_build = True

  elif (".css" in f) or (".html" in f):
    should.reload_browser = True

  # Other
  else:
    p("unknown file: " + f, end="")

def process_stdin():
  should = Should()

  for f in sys.stdin:
    if "***BATCHEND***" in f:
      execute(should)
      should = Should()
    else:
      f, reason = f.strip().split(" ")
      if not ignore(f, reason):
        p("\nDetected change (" + reason + "): " + f, end="")
        mark(should, f)


def initial_compile():
  should = Should()
  should.ocaml_build = True
  should.elm_package = True
  execute(should)

def main():
  initial_compile()
  run_in_background(process_stdin)

main()
