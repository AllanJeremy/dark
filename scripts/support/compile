#!/usr/bin/env python3.6

import sys
import subprocess
import glob
import os.path as path
import time

# Make io unbuffered
def flush(fn):
  def newfn(x):
    fn(x)
    sys.stdout.flush()
  return newfn
sys.stdout.write = flush(sys.stdout.write)
sys.stdout.writelines = flush(sys.stdout.writelines)

def run(start, bash):
  proc = subprocess.run(bash, shell=True)
  stop = time.time()
  print(">> In " + str(stop-start) + "s")
  return proc.returncode == 0

###################
# Build logic
###################
def pretty_print(msg, color):
  global machine
  if not machine:
    print('\x1b[6;30;' + str(color) + 'm' + "\n$ " + msg + '\x1b[0m')

def run_frontend(start, bash):
  pretty_print(bash, 44)
  return run(start, bash)

def run_backend(start, bash):
  pretty_print(bash, 42)
  return run(start, bash)

def run_test(start, bash):
  pretty_print(bash, 45)
  return run(start, bash)

def elm_package():
  start = time.time()
  return run_frontend(start, "cd client && elm-package install --yes")

def elm_make():
  start = time.time()
  global machine
  if machine:
    return run_frontend(start, "cd client && elm-make --report=json Main.elm --output=/dev/null")
  else:
    # unbuffer makes elm think it's talking a terminal
    return run_frontend(start, \
            "cd client" \
            + " && unbuffer elm-make Main.elm" \
            + " --warn --debug --yes --output" \
            + " ../server/static/elm.js" \
            + " && cd .." \
            + " && patch -p0 < integration-tests/elm.js.patch")

def convert_dark_file_to_graph(filename):
  return subprocess.check_output(["ocamlrun", "server/_build/default/bin/darkfile_to_rpc.bc", filename])

def stringify(json):
  return json.decode() \
             .replace("\\", "\\\\") \
             .replace("\"", "\\\"") \
             .replace("\n", "\\n") \
             .replace("\r", "\\r")

def generate_elm_test_data():
  graphs = []
  names = []
  for d in glob.glob("server/appdata/test_*.dark"):
    name = path.basename(path.splitext(d)[0]).replace("test_", "")
    names.append(name)
    graphs.append(stringify(convert_dark_file_to_graph(d)))
  filename = "client/tests/DarkTestData.elm"
  testnames = "\n  , ".join(names)
  tests = [n + " : (String, String)\n" + n + " = (\"" + n + "\", \"" + g + "\")\n" for (n,g) in zip(names,graphs)]
  output = """module DarkTestData exposing (..)

tests : List (String, String)
tests =
  [ """ + testnames + """
  ]

""" + "\n\n".join(tests)

  with open(filename, "w") as file:
    file.write(output)


def elm_test():
  start = time.time()
  ocaml_build_converter()
  generate_elm_test_data()
  return run_test(start, "cd client && unbuffer elm-test")

def less_compile():
  start = time.time()
  return run_frontend(start, "lessc server/static/base.less server/static/base.css")

landmarks = " OCAML_LANDMARKS='time,allocation,on,auto,format=json,output=profile.json'"
def ocaml_build():
  start = time.time()
  global profile
  cd = "cd server &&"
  build = " jbuilder build bin/main.bc "
  if profile:
    return run_backend(start, cd + landmarks + build)
  else:
    return run_backend(start, cd + build)

def ocaml_build_converter():
  start = time.time()
  run_test(start, "cd server && jbuilder build bin/darkfile_to_rpc.bc")

def ocaml_test():
  start = time.time()
  return run_backend(start, "cd server && jbuilder build test/test.bc && unbuffer ocamlrun _build/default/test/test.bc 2>&1")

def reload_server():
  start = time.time()
  global profile
  cd = "cd server &&"
  runserver = "../scripts/support/runserver"
  if profile:
    return run_backend(start, cd + landmarks + runserver)
  else:
    return run_backend(start, cd + runserver)

def reload_browser():
  start = time.time()
  # Sends a signal to another fswatch on your mac
  return run_frontend(start, "touch .browser-trigger")

class Should:
  def __init__(self):
    self.ocaml_build = False
    self.ocaml_test = False
    self.elm_package = False
    self.elm_make = False
    self.elm_test = False
    self.less_compile = False
    self.reload_browser = False
    self.reload_server = False

def execute(should):
  ob = should.ocaml_build and ocaml_build()
  should.reload_server |= ob
  rs = should.reload_server and reload_server()

  ep = should.elm_package and elm_package()
  should.elm_make |= ep
  em = should.elm_make and elm_make()

  lc = should.less_compile and less_compile()

  should.reload_browser |= rs or em or lc
  rb = should.reload_browser and reload_browser()

  should.ocaml_test |= ob
  ot = should.ocaml_test and ocaml_test()
  should.elm_test |= em
  et = should.elm_test and elm_test()


def mark(should, f):
  # Frontend
  if "elm-package.json" in f:
    should.elm_package = True
  elif "Tests.elm" in f:
    should.elm_test = True
  elif "server/testdata/" in f:
    should.elm_test = True
  elif ".elm" in f or ".js" in f:
    should.elm_make = True

  # Ocaml
  elif "test/test.ml" in f:
    should.ocaml_test = True

  elif (".ml" in f) or ("jbuild" in f) or ("_tags" in f):
    should.ocaml_build = True

  # Web
  elif ".less" in f:
    should.less_compile = True

  elif ".html" in f:
    should.reload_browser = True

  # Other
  else:
    print("unknown file: " + f, end='')

  return should



def ignore(filename):
  # substring
  ignores = [ ".git"
            , "scripts/"
            , "logs/"
            , ".merlin"
            , "client/elm-stuff"
            , "client/tests/elm-stuff"
            , "client/repl-temp"
            , "client/tests/DarkTestData.elm"
            , "server/static/elm.js"
            , "server/static/base.css"
            , "server/cache/"
            , "server/_build/"
            , "server/dark.install"
            , "server/_build/"
            , "server/appdata/"
            , "server/gmon.out"
            , "server/profile.json"
            , "server/ocamlbuild_output.txt"
  ]
  for i in ignores:
    if i in filename:
      return True
  # ocaml build temporary
  if filename[-10:-8] == "/C":
    return True
  # emacs thing
  if "/.#" in filename:
    return True
  return False


machine = False # Don't print pretty things, use different formatting
profile = False # Run ocaml stuff under the landmarks profiler
files = []
def main():
  global machine
  for f in sys.argv[1:]:
    if f == "--machine":
      machine = True
    elif not ignore(f):
      files.append(f)

  if len(files) > 0:
    pretty_print("Compiling: " + str(files), 43)

    should = Should()
    for f in files:
      mark(should, f)

    execute(should)

main()
